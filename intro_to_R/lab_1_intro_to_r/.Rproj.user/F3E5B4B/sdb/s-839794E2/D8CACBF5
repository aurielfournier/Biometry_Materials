{
    "contents" : "---\ntitle: \"A quick introduction to R\"\noutput: html_document\n---\n\nOriginally written by Matt Boone, modified by Auriel Fournier \n\n###Basics\nR is a language and a suite of software for programming and data analysis.\n  \n  - Based on the S language written in the 70's\n  - **_R_** is used interchangeably to refer to the program and the language\n  - Typically users use RStudio as an easier interface\n\n###R Studio\n\n  - Not created by the original writers of R. \n  - Allows the user to see and explore the variables, including sorting.\n  - Can manage many codes at once\n  - Easily search help files\n  \n##Data Classes\nR has 5 main data types, but there are numerous types available\nThese tell R whether 1 means the number 1 (numeric) which we can do math with or the letter representation '1' which has no numeric value\n\n###Numeric\nThese are just standard numbers, whether integers or decimals, either one is numeric  \n```{R}\n1\n1.1\n\n\n```\n\n###Integers\nIntegers are also numeric, but integers are whole numbers with no decimal. As we can see, the integer of both 1.1 and 1 is 1\n```{R}\nas.integer(1.1)\nas.integer(1)\n```\n###Character\nThese are just letters, they have no numeric value associated with them. R reads these as one long 'string'. \n```{R}\nstr( 'Luke Skywalker')\n\n```\nInfact, R sees this phrase not as 2 words 'luke' and 'skywalker' but the string of characters 'luke','(space)','skywalker'. Which is 14 spaces long\n```{R}\nnchar('Luke Skywalker')\n\n```\n###Factor\nFactors are character strings that have some sort of order to them. Like monday, tuesday, and wednesday. In this case the characters are representing objects with some inherit value (an order really 1,2,3 etc...). So say we have the star wars movies\n```{R}\nstar_wars<-factor(c('A New Hope', 'Empire Strikes Back', 'Return of the Jedi', 'The Phantom Menace', 'Attack of the Clones', 'Revenge of the Sith','The Force Awakens'))\n\nlevels(star_wars)\n```\nThe names do represent something to us, but they don't necessarily have any value. We can, however, give them a value, say we want their order to represent how we personally rank them. We can do this by either giving the object an order via the levels() function.\n```{R}\nlevels(star_wars)<-c('Empire Strikes Back', 'A New Hope', 'The Force Awakens','Revenge of Sith', 'Return of Jedi', 'The Phantom Menace', 'Attack of Clones')\n\nstar_wars\n```\nOr by originally telling it what the levels are\n```{R}\nstar_wars<-factor(c('A New Hope', 'Empire Strikes Back', 'Return of the Jedi', 'The Phantom Menace', 'Attack of the Clones', 'Revenge of the Sith','The Force Awakens'), levels= c('Empire Strikes Back', 'A New Hope', 'The Force Awakens','Revenge of Sith', 'Return of Jedi', 'The Phantom Menace', 'Attack of Clones'))\n\nlevels(star_wars)\n```\n\n###Logical\nLogical is just TRUE or FALSE, there's only 2 possible states, yes or no, on and off, which is represented by True or False. R understands this in 3 different ways. Captial letters TRUE and FALSE\n```{R}\nis.logical(TRUE)\n```\nJust the letters T and F\n```{R}\nis.logical(F)\n```\nOr by the numbers 1 or 0. Which R can convert to logical. \n\n```{R}\nas.logical(c(1,0,1))\n```\n\n##Data Types\nR has 4 main data types\nThese are structural types your data can be stored in. They are defined by if they take more than one class type and the dimensions of the data  \n\n###Vectors\nThis is a 1 dimensional data set that (only dimension is length) and it can only consist of the same data class. c() creates a vector\n```{R}\nc(1,2,4)\n\nc(1,2,3,4,5,6)\n```\nR attempts to coherse the data into the class it has in common. So if we have two entries 1 and mom, it will coherse them both to characters because 1 can be converted to a character, but mom can not be converted to a number\n```{R}\n\n\nc(1,  'mom')\nstr( c(1,  'mom') )\n```\n###Matrices\nThis is a 2 dimensional container/array that are all of the same data type\n\n  - essentially a 2 dimensional vector (dimensions are rows and columns)\n```{R}\nmatrix_1<-matrix(1:100, nrow=2, ncol=50)\nmatrix_1\n```\nWe can refer to each of these by their position using brackets [ , ]. The left position is the row and the right is the column: data[row, column ].   \nThey can only be of the same data class\n```{R}\nmatrix_1[2, ]\n\n```\n\n###Data.frames\nData.frames are 2 dimensional array, where each column is the same data class. So we can have multiple data classes in one container. The right side of the equals sign will automatically give the name to the column\n\n```{R}\ndd<-data.frame(id = 1:5, value = c('a','b','c','d','e'))\ndd\n```\nWe can also manually define the column names\n```{R}\ncolnames(dd)<-c('monkeys','gorillas')\ndd\n```\nYou can refer to column names either by their position or by the column name:\n```{R}\ndd$monkeys\ndd[,1]\n```\n\n###Lists\nLists are containers for the other data types. Can contain any data.type and can be any dimension. You can name lists in the same way as column names in data.frames. They are the storage containers for your data. Think of them like a tackle box / or jewlery box that contain your data with varying sizes and types of items in each bin. At a basic level they're useful for storing data of different types, at a more advanced level you can do all of your data analysis in them using the lapply function.\n```{R}\nlist_1<-list(id= 1:4, names=c('1','2'), data_1 = data.frame(id=1:10, rep(c('a','b'),5)))\nlist_1\n\nlist_1$data_1$id   ###you can refer to items and columns in the same way you would a dataframe, but hierarchically\n\nnames(list_1)\n\nstr(list_1)\n\n\n```\n####Arrays\nArrays are multi-dimensional matrices, all data has to be the same data.class though.\n\n  - A 2 dimensional array is a matrix\nIn this following example we are going to make a 2x2x5 dimensiaonl array. Think of this 3d example as an apartment complex with 4 rooms on each level and 5 levels total. We can make arrays as many dimensions as possible.\n```{R}\ndata<-array(1:100, dim=c(2,2,5))\ndata\n```\n##Function interface\nOne of the goals of the writers of the S language was to make it easy to go from idea, to implementation of analysis or creation of software\n\n  - basically all operations in R are written as functions\n```{R}\nhead(mtcars)\n\n\n###Subset is really just a function thats essentially subsetting like you would \nsubset(mtcars, mpg>30)\nmtcars[mtcars$mpg>30,]\n#These are equivalent\n```\n\nin this example we can see calling a function shows us that R is hiding all the code behind the scenes. \n\n```{r}\n#  ordinal_date_con\n# function (x) \n# {\n#     x <- apply(x, 2, as.numeric)\n#     x <- matrix(x, ncol = 3)\n#     varmonth <- cbind(c(1:12), c(0, 31, 59, 90, 120, 151, 181, \n#         212, 243, 273, 304, 334))\n#     juldates <- data.frame(odate = as.numeric())\n#     for (i in 1:nrow(x)) {\n#         juldates[i, 1] <- varmonth[which(x[i, 1] == varmonth[, \n#             1]), 2] + x[i, 2]\n#     }\n#     juldates$odate\n# }\n```\n\n\n\n\nBut we can actually do this as well!\n\n\nSay we want to write a function to calculate Standard Error\nTip: Remember the object names inside 'function()' is the **variable** r stores your input as. So whatever vector we give to our new function, R will store that vector as 'data'. We then proceed under the assumption that our vector is now called 'data'\n```{R}\n#SD/sqrt(n)\n\nSEM<-function(data){\n  \n  sd(data)/length(data)\n  \n  \n}\n\nSEM(data=1:10000)\n\n```\nNow no matter what numerical vector we put into SEM(), it will give us the standard error. It does this by finding the standard error, and then infering the 'n' by calculating the length of the vector (which are essentially the same thing!)\n\n\n\n```{r}\nlibrary(gapminder)\ndatag<-gapminder\n\nhead(datag)   \n\n\n\ndatag$continent=='Europe'    ###shows us what rows continent equals Europe\ndatag[datag$continent=='Europe', ]    ##If we feed this string of T and F into our data frame, it only shows us the rows where continent equals Europe\ndatag$year==1987    ##shows us what rows year equals 1987\ndatag[datag$year==1987, ]   \n\n\ndatag[datag$continent=='Europe' | datag$continent=='Asia' & datag$year==1987, ]\n\n\n\n\n```\n\n\n\n# Match\n\n```{r}\n\n\n\n# Match\n# %in%   #the original match() function was rewritten to %in%\n\n# find all the variables in 'this' that are also in 'that'\nthis<-c(1:10)\nthat<-c(1,2)\n\nthis %in% that  \n\n\n```\n\n\n\n```{r}\ndata <- read.csv('./lab_1_intro_to_r/rail_data.csv')\ndata\n\n# lets subset our data into two dataframes for ease in this example. \ndata1 <- data[ ,1:3]    #a data frame called data1\ngrouping <- data[ ,4:5]  #and our grouping variables called grouping\n\n# tapply runs a function on a vector based on a set of groupings we feed it\ntapply(data$wingchord, data$genera, mean)  \n\ndata  \n\n# the groupings we give it have to be a vector of the same length as our vector because otherwise it will have moments where it doesnt know how to groupthem\n\n# by runs a function on a DATAFRAME based on a vector of groupings\n\nby(data, data$genera, data.frame)\n\n\n\n```\n\n\n# the 'dplyr' package is GREAT at summarizing and manipulating data, especially when used with the 'tidyr' package. \n\n\n```{r}\nname <- 'Matt'\npaste('Hello, world. My name is',name )    # pastes the phrase, 'hellow world my name is', with our object name, which we stored as Matt\n\nversion<-2.1\n\n# this is useful for error messages\n\npaste0(name,'_',version,' was not found')\n\npaste0(name,'_',version,' was not found, please try ', version-1 )  # notice we can still do math on things. R evaluates from the inside of a function outward.\n\n#its also useful to add numbers to the end, it will also recycle as necessary\n\npaste0(name,1:10) \n\n\n\n```\n\n\n\n```{r}\n\n\ndata <- matrix(runif(100,0,1),nrow=10)\n\n# multiplying vectors and matrices\n\ndata*1:10       # 'pseudo' matrix multiplication. Runs 1:10 on each column.\n\ndata %*% 1:10   # matrix multiplication. This is how you do real matrix multiplication \n\n```\n\n```{r}\n\nSys.time()\n\ndt<-as.Date(Sys.time(),format='%Y-%m-%d')\nct<-as.POSIXct(Sys.time(),format='%Y-%m-%d %H%M%D')\nlt<-as.POSIXlt(Sys.time(),format='%Y-%m-%d %H%M%D')\n\n\n\n```\n\n```{r}\nlibrary(dplyr)\n# pipes can be used to write code which is more readable by people\n\nhead(data)\n\ndata %>% head\n\n# reads as data then head\n\ndata %>% summary\n\n# reduces the number of parentheses, which can be very helpful\n\n```\n\n##Good places to go from here\n**Baby steps**\nFor some who is just starting out and who is new to statistical software in general  \n[SWIRL!](http://swirlstats.com/students.html)\n\nIf you want to tackle learning R in a more ambitious or complete manner, I suggest taking the coursera course, which is free and runs essentially every month. [Coursera](\nhttps://www.coursera.org/courses/rprog)  \n\nfor good information on programming in R check out software carpetentry \n\nhttp://swcarpentry.github.io/r-novice-inflammation/\n\nfor good information on data management in R check out data carpentry\n\nhttp://www.datacarpentry.org/R-ecology/\n\nAuriel is an instructor for both software and data carpentry and can answer questions\n\nAnd then move onto: [Advanced R](http://adv-r.had.co.nz/)\n\nThis advanced course, is really just an html version of Hadley Wickhams advanced R book. It's written using Markdown, and by the end of it should give you a fluent grasp on R",
    "created" : 1453322237427.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4212818644",
    "id" : "D8CACBF5",
    "lastKnownWriteTime" : 1453322706,
    "path" : "C:/Users/avand/Documents/Biometry_Materials/intro_to_R/Intro_R.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}